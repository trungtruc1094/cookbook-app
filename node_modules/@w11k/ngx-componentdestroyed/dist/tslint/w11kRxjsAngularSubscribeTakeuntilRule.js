"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tsquery_1 = require("@phenomnomnominal/tsquery");
var Lint = require("tslint");
var util_1 = require("./util");
function getClassesWithAnnotation(sourceFile, annotationName) {
    var componentAnnotations = tsquery_1.tsquery(sourceFile, "ClassDeclaration Decorator CallExpression Identifier[name='" + annotationName + "']");
    return componentAnnotations.map(function (ca) { return ca.parent.parent.parent; });
}
function hasImport(sourceFile, moduleName, namedImport) {
    var importFound = false;
    var angularCoreImports = tsquery_1.tsquery(sourceFile, "ImportDeclaration StringLiteral[value='" + moduleName + "']");
    angularCoreImports.forEach(function (stringLiteral) {
        var componentImports = tsquery_1.tsquery(stringLiteral.parent, "NamedImports Identifier[name='" + namedImport + "']");
        if (componentImports.length > 0) {
            importFound = true;
        }
    });
    return importFound;
}
// noinspection JSUnusedGlobalSymbols
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        var _this = this;
        var failures = [];
        var typeChecker = program.getTypeChecker();
        var relevantClasses = [];
        if (hasImport(sourceFile, "@angular/core", "Component")) {
            relevantClasses = relevantClasses.concat(getClassesWithAnnotation(sourceFile, "Component"));
        }
        if (hasImport(sourceFile, "@angular/core", "Directive")) {
            relevantClasses = relevantClasses.concat(getClassesWithAnnotation(sourceFile, "Directive"));
        }
        if (hasImport(sourceFile, "@angular/core", "Pipe")) {
            relevantClasses = relevantClasses.concat(getClassesWithAnnotation(sourceFile, "Pipe"));
        }
        if (hasImport(sourceFile, "@angular/core", "Injectable")) {
            relevantClasses = relevantClasses.concat(getClassesWithAnnotation(sourceFile, "Injectable"));
        }
        relevantClasses.forEach(function (classDeclaration) {
            var propertyAccessExpressions = tsquery_1.tsquery(classDeclaration, "CallExpression PropertyAccessExpression[name.name=\"subscribe\"]");
            propertyAccessExpressions.forEach(function (node) {
                var propertyAccessExpression = node; // .subscribe
                var type = typeChecker.getTypeAtLocation(propertyAccessExpression.expression);
                if (util_1.couldBeType(type, "Observable")) {
                    var name_1 = propertyAccessExpression.name;
                    var objWithSubscribeExpression = propertyAccessExpression.expression;
                    var beforeSubscribeExpression = objWithSubscribeExpression.expression;
                    if (beforeSubscribeExpression === undefined
                        || beforeSubscribeExpression.name === undefined
                        || beforeSubscribeExpression.name.escapedText !== "pipe") {
                        failures.push(new Lint.RuleFailure(sourceFile, name_1.getStart(), name_1.getStart() + name_1.getWidth(), "Missing `.pipe(...)` before .subscribe()", _this.ruleName));
                        return;
                    }
                    var pipeCallArguments = objWithSubscribeExpression.arguments;
                    var missingTakeUntil = false;
                    if (pipeCallArguments.length === 0) {
                        missingTakeUntil = true;
                    }
                    else {
                        var lastArg = pipeCallArguments[pipeCallArguments.length - 1];
                        var takeUntilCall = lastArg.expression;
                        if (takeUntilCall.escapedText !== "takeUntil"
                            && takeUntilCall.escapedText !== "untilComponentDestroyed") {
                            missingTakeUntil = true;
                        }
                    }
                    if (missingTakeUntil) {
                        failures.push(new Lint.RuleFailure(sourceFile, name_1.getStart(), name_1.getStart() + name_1.getWidth(), "Missing `takeUntil(...) or untilComponentDestroyed(this)` as last pipe-operator", _this.ruleName));
                        return;
                    }
                }
            });
        });
        return failures;
    };
    // noinspection JSUnusedGlobalSymbols
    Rule.metadata = {
        description: "Enforces that `.pipe(..., takeUntil(...))` is called before `.subscribe()` within an Angular component/directive/pipe.",
        options: null,
        optionsDescription: "Not configurable.",
        requiresTypeInfo: true,
        ruleName: "w11k-rxjs-angular-subscribe-takeuntil",
        type: "style",
        typescriptOnly: true
    };
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
